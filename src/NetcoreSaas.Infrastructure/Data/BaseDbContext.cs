using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using NetcoreSaas.Domain.Models.App.Contracts;
using NetcoreSaas.Domain.Models.App.Employees;
using NetcoreSaas.Domain.Models.Core.Common;
using NetcoreSaas.Domain.Models.Core.Links;
using NetcoreSaas.Domain.Models.Core.Subscriptions;
using NetcoreSaas.Domain.Models.Core.Tenants;
using NetcoreSaas.Domain.Models.Core.Users;
using NetcoreSaas.Domain.Models.Core.Workspaces;
using NetcoreSaas.Domain.Models.Interfaces;
using NetcoreSaas.Infrastructure.Helpers;

namespace NetcoreSaas.Infrastructure.Data
{
    public class BaseDbContext : DbContext
    {
        // Core
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<TenantUser> TenantUsers { get; set; }
        public DbSet<Tenant> Tenants { get; set; }
        public DbSet<TenantProduct> TenantProducts { get; set; }
        public DbSet<TenantJoinSettings> TenantJoinSettings { get; set; }
        public DbSet<User> Users { get; set; }
        public DbSet<SubscriptionProduct> SubscriptionProducts { get; set; }
        public DbSet<SubscriptionPrice> SubscriptionPrices { get; set; }
        public DbSet<SubscriptionFeature> SubscriptionFeatures { get; set; }
        public DbSet<Workspace> Workspaces { get; set; }
        public DbSet<WorkspaceUser> WorkspaceUsers { get; set; }
        public DbSet<Link> Links { get; set; }
        public DbSet<LinkInvitation> LinkInvitations { get; set; }
        
        // App
        public DbSet<Contract> Contracts { get; set; }
        public DbSet<ContractEmployee> ContractEmployee { get; set; }
        public DbSet<ContractActivity> ContractActivity { get; set; }
        public DbSet<Employee> Employees { get; set; }

        public BaseDbContext(DbContextOptions options)
        {
            
        }
        
        protected void AddTenantToProperties(Guid? userId = null,Guid? tenantId = null,Guid? workspaceId = null)
        {
            ChangeTracker.DetectChanges();
            var added = ChangeTracker.Entries()
                .Where(t => t.State == EntityState.Added)
                .Select(t => t.Entity)
                .ToArray();
            
            foreach (var entity in added)
            {
                if (entity is IEntity baseEntity)
                {
                    baseEntity.CreatedAt = DateTime.Now;
                }
                if (entity is IAppEntity appEntity)
                {
                    if(tenantId.HasValue)
                        appEntity.TenantId = tenantId.Value;
                    if(userId.HasValue)
                        appEntity.CreatedByUserId = userId.Value;
                }
                if (entity is IAppWorkspaceEntity trackWorkspaceEntity)
                {
                    if(workspaceId.HasValue)
                        trackWorkspaceEntity.WorkspaceId = workspaceId.Value;
                }
            }
            var modified = ChangeTracker.Entries().Where(t => t.State == EntityState.Modified).Select(t => t.Entity).ToArray();

            foreach (var entity in modified)
            {
                if (entity is IEntity track)
                {
                    track.ModifiedAt = DateTime.Now;
                }
                if (entity is IAppEntity appEntity)
                {
                    if(userId.HasValue)
                        appEntity.ModifiedByUserId = userId;
                }
            }
        }
        
        protected List<AuditEntry> OnBeforeSaveChanges()
        {
            ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            foreach (var entry in ChangeTracker.Entries())
            {
                if (entry.Entity is AuditLog || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new AuditEntry(entry)
                {
                    TableName = entry.Metadata.GetTableName()
                };
                auditEntries.Add(auditEntry);

                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                            {
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
            {
                AuditLogs.Add(auditEntry.ToAudit());
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return auditEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }

        protected Task AuditOnAfterSaveChanges(List<AuditEntry> auditEntries)
        {
            if (auditEntries == null || auditEntries.Count == 0)
                return Task.CompletedTask;

            foreach (var auditEntry in auditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                AuditLogs.Add(auditEntry.ToAudit());
            }

            return SaveChangesAsync();
        }
    }
}
